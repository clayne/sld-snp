ScriptName _LEARN_ControlScript extends Quest ; conditional
; This script is the mod's main script. It is attached to the player
; via an alias in the mod's quest, and it is reponsible for managing the spell list
; and initializing the mod's variables and functions on first runs and upgrades.
; Since it is attached to the player via the quest, any events reported by the engine
; which are generated by the player can also be handled here, such as OnSleep, OnCast, etc.

GlobalVariable property _LEARN_CountAlteration auto
GlobalVariable property _LEARN_CountConjuration auto
GlobalVariable property _LEARN_CountDestruction auto
GlobalVariable property _LEARN_CountIllusion auto
GlobalVariable property _LEARN_CountRestoration auto
GlobalVariable property _LEARN_CountBonus auto
GlobalVariable property _LEARN_MinChanceStudy auto
GlobalVariable property _LEARN_MaxChanceStudy auto
GlobalVariable property _LEARN_MinChanceDiscover auto
GlobalVariable property _LEARN_MaxChanceDiscover auto
GlobalVariable property _LEARN_BonusScale auto
GlobalVariable property _LEARN_MaxFailsBeforeCycle auto
GlobalVariable property _LEARN_RemoveSpellBooks auto
GlobalVariable property _LEARN_CollectNotes auto
GlobalVariable property _LEARN_ForceDiscoverSchool auto
GlobalVariable property _LEARN_StudyInterval auto
GlobalVariable property _LEARN_AutoNoviceLearningEnabled auto
GlobalVariable property _LEARN_AutoNoviceLearning auto
GlobalVariable property _LEARN_ParallelLearning auto
GlobalVariable property _LEARN_HarderParallel auto
GlobalVariable property _LEARN_DreadstareLethality auto
GlobalVariable property _LEARN_EffortScaling auto
GlobalVariable property _LEARN_AutoSuccessBypassesLimit auto
GlobalVariable property _LEARN_TooDifficultEnabled auto
GlobalVariable property _LEARN_TooDifficultDelta auto
GlobalVariable property _LEARN_SpawnItems auto
GlobalVariable property _LEARN_PotionBypass auto
GlobalVariable property _LEARN_IntervalCDR auto
GlobalVariable property _LEARN_IntervalCDREnabled auto
GlobalVariable property _LEARN_MaxFailsAutoSucceeds auto
GlobalVariable property _LEARN_DynamicDifficulty auto
GlobalVariable property _LEARN_ConsecutiveDreadmilk auto
GlobalVariable property _LEARN_LastSetHome auto
GlobalVariable property _LEARN_LastDayStudied auto
GlobalVariable property _LEARN_AlreadyUsedTutor auto
GlobalVariable property _LEARN_DiscoverOnSleep auto
GlobalVariable property _LEARN_LearnOnSleep auto
GlobalVariable property _LEARN_maxNotes auto
GlobalVariable property _LEARN_maxNotesBonus auto
String[] effortLabels

GlobalVariable property _LEARN_EnthirSells auto
_LEARN_enthirChestAlias property enthirChestAlias auto
_LEARN_tolfdirChestAlias property tolfdirChestAlias auto

Keyword property LocTypeTemple auto
Location property WinterholdCollegeLocation auto
Keyword property LocTypePlayerHouse auto
Keyword property LocTypeInn auto
Location property customLocation auto

Actor property PlayerRef auto
GlobalVariable property GameHour auto
GlobalVariable property GameDaysPassed auto
Book property _LEARN_SpellNotesAlteration auto
Book property _LEARN_SpellNotesConjuration auto
Book property _LEARN_SpellNotesDestruction auto
Book property _LEARN_SpellNotesIllusion auto
Book property _LEARN_SpellNotesRestoration auto
MagicEffect Property AlchDreadmilkEffect auto
MagicEffect Property AlchShadowmilkEffect auto
MagicEffect Property _LEARN_PracticeEffect auto
Spell Property _LEARN_DiseaseDreadmilk auto
Spell property _LEARN_PracticeAbility auto
Spell property _LEARN_SummonSpiritTutor auto
Spell property _LEARN_SetHomeSp auto
Spell property _LEARN_StudyPower auto
Spell property _LEARN_SpellsToLearn auto
Book property _LEARN_SpellTomeSummonSpiritTutor auto
Book property _LEARN_SetHomeSpBook auto

LeveledItem property LitemSpellTomes00Alteration auto
LeveledItem property LitemSpellTomes00Conjuration auto
LeveledItem property LitemSpellTomes00Destruction auto
LeveledItem property LitemSpellTomes00Illusion auto
LeveledItem property LitemSpellTomes00Restoration auto
LeveledItem property LitemSpellTomes25Alteration auto
LeveledItem property LitemSpellTomes25Conjuration auto
LeveledItem property LitemSpellTomes25Destruction auto
LeveledItem property LitemSpellTomes25Illusion auto
LeveledItem property LitemSpellTomes25Restoration auto
LeveledItem property LitemSpellTomes50Alteration auto
LeveledItem property LitemSpellTomes50Conjuration auto
LeveledItem property LitemSpellTomes50Destruction auto
LeveledItem property LitemSpellTomes50Illusion auto
LeveledItem property LitemSpellTomes50Restoration auto
LeveledItem property LitemSpellTomes75Alteration auto
LeveledItem property LitemSpellTomes75Conjuration auto
LeveledItem property LitemSpellTomes75Destruction auto
LeveledItem property LitemSpellTomes75Illusion auto
LeveledItem property LitemSpellTomes75Restoration auto
LeveledItem property LootWarlockRandom auto
LeveledItem property LootRandomBanditWizard auto
LeveledItem property LootForswornRandomWizard auto
LeveledItem property LootLearningDrugs auto
LeveledItem property LootWarlockSpellTomes00All15 auto

Float LastLearnTime
Float LastDiscoverTime
Float LastSleepTime
int iFailuresToLearn
String[] aSchools

LeveledItem[] aAlterationLL
LeveledItem[] aConjurationLL
LeveledItem[] aDestructionLL
LeveledItem[] aIllusionLL
LeveledItem[] aRestorationLL
LeveledItem[] aInventSpellsPtr

Spell[] aSpells
int iHead
int iTail = -1
int iMaxSize
int iCount
Form[] _spells
int currentVersion; save active version

bool property CanUseLocalizationLib = false auto;
int property LIST_HEAD_SPARE_COUNT = 8 autoReadOnly
int property LIST_PURGE_AFTER = 31 autoReadOnly
string property SPELL_SCHOOL_ALTERATION = "Alteration" autoReadOnly
string property SPELL_SCHOOL_CONJURATION = "Conjuration" autoReadOnly
string property SPELL_SCHOOL_DESTRUCTION = "Destruction" autoReadOnly
string property SPELL_SCHOOL_ILLUSION = "Illusion" autoReadOnly
string property SPELL_SCHOOL_RESTORATION = "Restoration" autoReadOnly

int property NOTIFICATION_REMOVE_BOOK = 0 autoReadOnly
int property NOTIFICATION_ADD_SPELL_NOTE = 1 autoReadOnly
int property NOTIFICATION_ADD_SPELL_LIST = 2 autoReadOnly
int property NOTIFICATION_ADD_SPELL_LIST_FAIL = 3 autoReadOnly
int property NOTIFICATION_LEARN_SPELL = 4 autoReadOnly
int property NOTIFICATION_LEARN_FAIL = 5 autoReadOnly
int property NOTIFICATION_MOVING_ON = 6 autoReadOnly
int property NOTIFICATION_DISCOVERY = 7 autoReadOnly
int property NOTIFICATION_DREADMILK = 8 autoReadOnly
int property NOTIFICATION_DREAM = 9 autoReadOnly
int property NOTIFICATION_STUDY = 10 autoReadOnly
int property NOTIFICATION_SPIRIT_TUTOR = 11 autoReadOnly
int property NOTIFICATION_TOO_SOON = 12 autoReadOnly
int property NOTIFICATION_ERROR = 13 autoReadOnly
int property NOTIFICATION_VANILLA_ADD_SPELL = 14 autoReadOnly
int property NOTIFICATION_FORCE_DISPLAY = 15 autoReadOnly
int[] property VisibleNotifications Auto Hidden
bool _canSetBookAsRead

; === MCM helper functions
String[] function getEffortLabels()
	return effortLabels
endFunction

String[] function getSchools()
    return aSchools
EndFunction

bool function bookExtensionEnabled()
    return _canSetBookAsRead
endFunction

bool function ToggleNotification(int id)
    if id < 0 || id > VisibleNotifications.Length
        return false
    endIf
    int v = 0;
    if VisibleNotifications[id] == 0
        v = 1
    endIf

    VisibleNotifications[id] = v
    return v as bool
endFunction

bool function EnableNotification(int id, bool v)
    if id < 0 || id > VisibleNotifications.Length
        return false
    endIf

    VisibleNotifications[id] = v as int
    return v
endFunction

function notify(String msg, int controlIndex)
    if (VisibleNotifications[controlIndex])
        Debug.Notification(msg)
    endIf
endFunction

; === Version and upgrade management
int function GetVersion()
    return 176; v 1.7.6
endFunction

function UpgradeVersion()
    bool displayedUpgradeNotice = false
    if (currentVersion < 176)
        string msg = "[Spell Learning] " + formatString1(__l("notification_version_upgrade", "Installed version {0}"), "1.7.6")
		if (!displayedUpgradeNotice)
			; don't display multiple upgrade messages
			Debug.Notification(msg)
			displayedUpgradeNotice = true
		endIf
        Debug.Trace(msg)
        updateSpellLearningEffect()
    endIf
    if (currentVersion < 175)
        string msg = "[Spell Learning] " + formatString1(__l("notification_version_upgrade", "Installed version {0}"), "1.7.5")
		if (!displayedUpgradeNotice)
			; don't display multiple upgrade messages
			Debug.Notification(msg)
			displayedUpgradeNotice = true
		endIf
        Debug.Trace(msg)
        ; Change default notification setting to prepare for better notifications
        VisibleNotifications = new int[16]
        VisibleNotifications[NOTIFICATION_REMOVE_BOOK] = 0 
        VisibleNotifications[NOTIFICATION_ADD_SPELL_NOTE] = 0
        VisibleNotifications[NOTIFICATION_VANILLA_ADD_SPELL] = 0
        VisibleNotifications[NOTIFICATION_ADD_SPELL_LIST] = 1
        VisibleNotifications[NOTIFICATION_ADD_SPELL_LIST_FAIL] = 1
        VisibleNotifications[NOTIFICATION_LEARN_SPELL] = 1
        VisibleNotifications[NOTIFICATION_LEARN_FAIL] = 1
        VisibleNotifications[NOTIFICATION_MOVING_ON] = 1
        VisibleNotifications[NOTIFICATION_DISCOVERY] = 1
        VisibleNotifications[NOTIFICATION_DREADMILK] = 1
        VisibleNotifications[NOTIFICATION_DREAM] = 1
        VisibleNotifications[NOTIFICATION_SPIRIT_TUTOR] = 1
        VisibleNotifications[NOTIFICATION_STUDY] = 1
        VisibleNotifications[NOTIFICATION_TOO_SOON] = 1
        VisibleNotifications[NOTIFICATION_ERROR] = 1
        VisibleNotifications[NOTIFICATION_FORCE_DISPLAY] = 1
    endIf
    if (currentVersion < 174)
		string msg = "[Spell Learning] " + formatString1(__l("notification_version_upgrade", "Installed version {0}"), "1.7.4")
		if (!displayedUpgradeNotice)
			; don't display multiple upgrade messages
			Debug.Notification(msg)
			displayedUpgradeNotice = true
		endIf
        Debug.Trace(msg)
        ; When upgrading, keep old default note scaling values
        ; These were not previously user-configurable so they need to be specified here
        if (currentVersion == 172)
            _LEARN_maxNotes.SetValue(10000)
            _LEARN_maxNotesBonus.SetValue(10)
        elseif (currentVersion == 173)
            _LEARN_maxNotes.SetValue(1800)
            _LEARN_maxNotesBonus.SetValue(20)
        endIf  
    endIf
	if (currentVersion < 173)
		string msg = "[Spell Learning] " + formatString1(__l("notification_version_upgrade", "Installed version {0}"), "1.7.3")
		if (!displayedUpgradeNotice)
			; don't display multiple upgrade messages
			Debug.Notification(msg)
			displayedUpgradeNotice = true
		endIf
		Debug.Trace(msg)
		; Set up new list of scaling options
		effortLabels = new String[3]
		effortLabels[0] = "Tough Start"
		effortLabels[1] = "Diminishing Returns"
		effortLabels[2] = "Linear"
		; If user is upgrading from the last version, disable new options to not disrupt
		; existing functionality for users. Unfortunately cannot cover older versions than
		; that because it was only 1.7.2 that introduced versioning
		if (currentVersion == 172)
			_LEARN_DynamicDifficulty.SetValue(0)
			_LEARN_IntervalCDREnabled.SetValue(0)
			_LEARN_AutoNoviceLearningEnabled.SetValue(0)
			_LEARN_MaxFailsAutoSucceeds.SetValue(0)
			_LEARN_TooDifficultEnabled.SetValue(0)
		endIf
		; Add study power
		PlayerRef.AddSpell(_LEARN_StudyPower, false)
		; Fix attunement cooldown
		if (GameDaysPassed.GetValue() >= 7)
			_LEARN_LastSetHome.SetValue(GameDaysPassed.GetValue() - 7)
		else
			_LEARN_LastSetHome.SetValue(0)
		endIf
	endIf
    if (currentVersion < 172)
        UpgradeSpellList()
		string msg = "[Spell Learning] " + formatString1(__l("notification_version_upgrade", "Installed version {0}"), "1.7.2")
		if (!displayedUpgradeNotice)
			; don't display multiple upgrade messages
			Debug.Notification(msg)
			displayedUpgradeNotice = true
		endIf
		Debug.Trace(msg)
    endIf
    currentVersion = GetVersion()
endFunction

function UpgradeSpellList()
    if aSpells || aSpells.Length > 1
        int i = 0
        int newCapacity = NihSldUtil.CalculateNextCapacity(iCount)
        _spells = Utility.CreateFormArray(newCapacity)
        while i < iCount
            _spells[i] = aSpells[(iHead + i) % iMaxSize]
            i += 1
        EndWhile
        iHead = 0
        iTail = iCount - 1
        iMaxSize = newCapacity
        aSpells = new Spell[1]; assigning None causes casting error
    endIf
endFunction

function InternalPrepare()
{Maintainence function}
    aSchools[0] = __l("mcm_automatic", "Automatic"); added here for mid-game localization support
    _canSetBookAsRead = SKSE.GetPluginVersion("BookExtension") != -1
    UpgradeVersion()
    ; Because this function InternalPrepare() is called on every load, we can refresh our LeveledList changes
    ; since they are not persistent in a save when added via script. This function checks
    ; conditions itself, so we don't need to here.
    SpawnItemsInWorld()
endFunction

; === Localization
string function __l(string keyName, string defaultValue = "")
    if CanUseLocalizationLib
        return _LEARN_Strings.__l(keyName, defaultValue);
    endIf
    if (defaultValue == "")
        return keyName;
    endIf
    return defaultValue 
endFunction

string function formatString1(string source, string p1)
    return _LEARN_Strings.StringReplaceAll(source, "{0}", p1)
endFunction

string function formatString2(string source, string p1, string p2)
    string r = formatString1(source, p1)
    return _LEARN_Strings.StringReplaceAll(r, "{1}", p2)
endFunction

int function GetMenuLangId()
    if CanUseLocalizationLib
        return _LEARN_Strings.GetMenuLangId()
    else
        return 0
    endIf
endFunction

; === Spell list management
function SpellListEnsureCapacity(int capacity)
    if capacity > iMaxSize
        int newSize = NihSldUtil.CalculateNextCapacity(capacity)
        if _spells
            _spells = Utility.ResizeFormArray(_spells, newSize)
        else
            _spells = Utility.CreateFormArray(newSize)
            iTail = -1
            iHead = 0
        endIf
        ;Debug.Trace(_LEARN_Strings.FormatString2("[Spell Learning] Spell capacity increased from {0} to {1}", iMaxSize, newSize))
        iMaxSize = newSize
    endIf
endFunction

int function CopySpells(Form[] targetList, int startIndex, int count)
{to get spells for paging faster. returns copied spell count}
    if startIndex < 0 || startIndex >= iCount
        return 0
    endIf
    if count + startIndex > iCount
        count = iCount - startIndex
    endIf
    int i = 0
    int delta = iHead + startIndex
    while i < count
        targetList[i] = _spells[delta + i]
        i += 1
    EndWhile
    return count
endFunction

int function spell_fifo_get_count()
    return iCount
EndFunction

bool function spell_fifo_has_ref(Spell sp)
    return (iCount > 0 && _spells.Find(sp as Form) >= 0)
EndFunction

int function spell_fifo_get_ref(Spell sp)
	if (iCount > 0 && _spells.Find(sp as Form) >= 0)
		return _spells.Find(sp as Form)
	Else
		return 0
	EndIf
EndFunction

Spell function spell_fifo_peek(int idx = 0)
    if idx < 0 || iCount <= idx
        return None
    endIf
    return _spells[iHead + idx] as Spell
EndFunction

Bool function spell_fifo_poke(int idx, Spell spx)
    if idx < 0 || iCount <= idx
        return false
    endIf
    _spells[iHead + idx] = spx
EndFunction

Spell function spell_fifo_remove_last()
    if iCount == 0
        return None
    endIf
    Spell tmp = _spells[iTail] as Spell
    _spells[iTail] = None
    iCount -= 1
    iTail -= 1
    return tmp
EndFunction

Spell function spell_fifo_push(Spell s) 
    ; add
    SpellListEnsureCapacity(iTail + 2)
    iTail += 1
    _spells[iTail] = s
    iCount += 1
    ; Since this is the main way spells are added to the list,
    ; let's update the spell learning effect once here instead of in every
    ; place we might add new spells to the list
    updateSpellLearningEffect()
    return s
EndFunction

Spell function spell_fifo_pop()
    ; remove first item and return it
    if iCount == 0
        return None
    endIf
    Spell tmp = _spells[iHead] as Spell
    _spells[iHead] = None
    iHead += 1
    iCount -= 1
    if iHead > LIST_PURGE_AFTER ; we check here to avoid framing
        PurgeSpellList()
    endIf
    return tmp
EndFunction

Spell function spell_list_removeAt(int index)
    if index < 0 || index >= iCount
        return None
    endIf
    int realIndex = index + iHead
    Spell tmp = _spells[realIndex] as Spell
    bool checkPurge = false

    if realIndex == iHead
        _spells[iHead] = None
        iHead += 1
        iCount -= 1
        checkPurge = true
    elseIf realIndex == iTail
        _spells[iTail] = None
        iCount -= 1
        iTail -= 1
    elseIf (realIndex - iHead) < (iTail - realIndex) ; we move items from start of the list
        int i = realIndex
        while i > iHead
            _spells[i] = _spells[i - 1]
            i -= 1
        EndWhile
        _spells[iHead] = None
        iHead += 1
        iCount -= 1
        checkPurge = true
    else ; we move items from end of the list
        int i = realIndex
        while i < iTail
            _spells[i] = _spells[i + 1]
            i += 1
        EndWhile
        _spells[iTail] = None
        iTail -= 1
        iCount -= 1
    endIf
    if checkPurge && iHead > LIST_PURGE_AFTER
        PurgeSpellList()
    endIf
    return tmp
endFunction

bool function forceLearnSpellAt(int index, bool useVanillaNotification)
    Spell spellToLearn = spell_list_removeAt(index)
    if spellToLearn
        if !PlayerRef.HasSpell(spellToLearn)
            PlayerRef.AddSpell(spellToLearn, useVanillaNotification)
            ; All spell learning in the mod goes through this method so
            ; we can remove the spell learning effect that lets
            ; the player know there are spells to learn here if needed.
            updateSpellLearningEffect()
            return true
        endIf
    endIf
    return false
endFunction

function PurgeSpellList()
    int spareHead = LIST_HEAD_SPARE_COUNT
    if iHead < spareHead
        return
    endIf
    ;Debug.Trace("[Spell Learning] Purging head=" + iHead + ",count=" + iCount + ",capacity=" + iMaxSize)
    int i = spareHead
    int topIndex = iCount + spareHead
    int delta = iHead - spareHead
    while i < topIndex
        _spells[i] = _spells[i + delta]
        i += 1
    EndWhile
    iTail -= delta
    iHead = spareHead

    ; add shrink functionality
    int requestedCapacity = iCount + (2 * spareHead)
    int calculatedCapacity = NihSldUtil.CalculateNextCapacity(requestedCapacity)
    if iMaxSize > calculatedCapacity
        ;Debug.Trace("[Spell Learning] shrinking from" + iMaxSize + " to " + calculatedCapacity)
        _spells = Utility.ResizeFormArray(_spells, calculatedCapacity)
        iMaxSize = calculatedCapacity
    endIf
    ;Debug.Trace("[Spell Learning] Purge completed head=" + iHead + ",count=" + iCount + ",capacity=" + iMaxSize)
    ;/ TODO: test this later
    if CanUseLocalizationLib ; PapyrusUtil is installed
        _spells = PapyrusUtil.SliceFormArray(_spells, iHead - spareHead, iMaxSize - 1)
        iMaxSize = _spells.Length
        iTail -= (iHead - spareHead)
        iHead = spareHead
    else
        int i = spareHead
        int topIndex = iCount + spareHead
        int delta = iHead - spareHead
        while i < topIndex
            _spells[i] = _spells[i + delta]
            i += 1
        EndWhile
        iTail -= delta
        iHead = spareHead
    endIf
    /;
endFunction

bool function MoveSpellToTop(int spellIndex)
    if spellIndex == 0
        return false
    endIf
    int realIndex = spellIndex + iHead
    Form item = _spells[realIndex]
    int i
    if iHead == 0 ;no free space at beginning
        i = realIndex
        while i
            _spells[i] = _spells[i - 1]
            i -= 1
        endWhile
        _spells[iHead] = item
    else 
        int lenL = realIndex - iHead
        int lenR = iTail - realIndex
        if (lenR < lenL) || (lenR == lenL && iHead > LIST_HEAD_SPARE_COUNT)
            i = realIndex
            while i < iTail
                _spells[i] = _spells[i + 1]
                i += 1
            endWhile
            iTail -= 1
            iHead -= 1
            _spells[iHead] = item
        else
            i = realIndex
            while i > iHead
                _spells[i] = _spells[i - 1]
                i -= 1
            endWhile
            _spells[iHead] = item
        endIf
    endIf
    return true
endFunction

bool function MoveSpellToBottom(int spellIndex)
    if spellIndex >= (iCount - 1)
        return false
    endIf
    int realIndex = spellIndex + iHead
    Form item = _spells[realIndex]
    int i

    int lenL = realIndex - iHead
    int lenR = iTail - realIndex
    
    if (lenL < lenR)
        i = realIndex
        while i > iHead
            _spells[i] = _spells[i - 1]
            i -= 1
        endWhile
        _spells[iHead] = None
        iHead += 1
        SpellListEnsureCapacity(iTail + 2)
        iTail += 1
        _spells[iTail] = item
    else
        i = realIndex
        while i < iTail
            _spells[i] = _spells[i + 1]
            i += 1
        endWhile
        _spells[iTail] = item
    endIf

    return true
endFunction

bool function MoveSpellToIndex(int spellIndex, int targetIndex)
    if spellIndex == targetIndex || spellIndex < 0 || spellIndex >= iCount
        return false
    endIf
    if targetIndex == 0
        return MoveSpellToTop(spellIndex)
    elseIf targetIndex >= (iCount - 1)
        return MoveSpellToBottom(spellIndex)
    endIf

    int realIndex = spellIndex + iHead
    int realTargetIndex = targetIndex + iHead
    Form tmp = _spells[realIndex]
    int displacement
    int leftCount
    int rightCount
    int i
    if (targetIndex < spellIndex) ; going left
        displacement = spellIndex - targetIndex
        leftCount = targetIndex
        rightCount = iCount - spellIndex - 1
        if iHead > 0 && (leftCount + rightCount) < displacement
            i = iHead
            while i < realTargetIndex ; moving left array to left
                _spells[i - 1] = _spells[i]
                i += 1
            endWhile
            iHead -= 1
            _spells[realTargetIndex - 1] = tmp
            i = realIndex
            while i < iTail ; moving right array to left
                _spells[i] = _spells[i + 1]
                i += 1
            endWhile
            _spells[iTail] = None
            iTail -= 1
        else ; move displacement
            i = realIndex
            while i > realTargetIndex
                _spells[i] = _spells[i - 1]
                i -= 1
            endWhile
            _spells[realTargetIndex] = tmp
        endIf
    else ; going right
        displacement = targetIndex - spellIndex
        leftCount = spellIndex
        rightCount = iCount - targetIndex - 1
        if (leftCount + rightCount) < displacement
            SpellListEnsureCapacity(iTail + 2)
            i = iTail
            while i > realTargetIndex ; moving right array to right
                _spells[i + 1] = _spells[i]
                i -= 1
            endWhile
            iTail += 1
            _spells[realTargetIndex + 1] = tmp
            i = realIndex
            while i > iHead ; moving left array to right
                _spells[i] = _spells[i - 1]
                i -= 1
            endWhile
            _spells[iHead] = None
            iHead += 1
        else
            i = realIndex
            while i < realTargetIndex
                _spells[i] = _spells[i + 1]
                i += 1
            endWhile
            _spells[realTargetIndex] = tmp
        endIf
    endIf

    return true
endFunction

bool function MoveSpellUp(int spellIndex)
    if spellIndex == 0
        return false
    endIf
    int realIndex = spellIndex + iHead
    
    Form tmp = _spells[realIndex]
    _spells[realIndex] = _spells[realIndex - 1]
    _spells[realIndex - 1] = tmp
    return true
endFunction

bool function MoveSpellDown(int spellIndex)
    if spellIndex >= (iCount - 1)
        return false
    endIf
    int realIndex = spellIndex + iHead
    
    Form tmp = _spells[realIndex]
    _spells[realIndex] = _spells[realIndex + 1]
    _spells[realIndex + 1] = tmp
    return true
endFunction

; === Mod initialization functions

function addLlToListIfMissing(LeveledItem listToAdd, LeveledItem list, int level, int count)
    int i = list.GetNumForms()
    While (i > 0)
        Form x
        x = list.GetNthForm(i)
        if (x == listToAdd)
            ; it's is already present in list
            return
        EndIf
        i = i - 1
    EndWhile
    ; If we get here, we haven't found the item in the list, so add it.
    list.addform(listToAdd, level, count)
endFunction

function addBookToListIfMissing(Book bookToAdd, LeveledItem list, int level, int count)
    int i = list.GetNumForms()
    While (i > 0)
        Book x
        x = list.GetNthForm(i) as Book
        if (x == bookToAdd)
            ; item is already present in list
            return
        EndIf
        i = i - 1
    EndWhile
    ; If we get here, we haven't found the item in the list, so add it.
    list.addform(bookToAdd, level, count)
endFunction

function SpawnItemsInWorld(); TODO Test.
    if (_LEARN_SpawnItems.GetValue() == 1)
        ; Spirit Tutor tome
        addBookToListIfMissing(_LEARN_SpellTomeSummonSpiritTutor, LitemSpellTomes00Conjuration, 1, 1)
        ; Attunement tome
        addBookToListIfMissing(_LEARN_SetHomeSpBook, LitemSpellTomes25Alteration, 1, 1)
        ; Drugs
        addLlToListIfMissing(LootLearningDrugs, LootWarlockRandom, 1, 1)
        addLlToListIfMissing(LootLearningDrugs, LootRandomBanditWizard, 1, 1)
        addLlToListIfMissing(LootLearningDrugs, LootForswornRandomWizard, 1, 1)
        ; Add more spell tome spawns to some mage enemies
        addLlToListIfMissing(LootWarlockSpellTomes00All15, LootWarlockRandom, 1, 1)
        addLlToListIfMissing(LootWarlockSpellTomes00All15, LootRandomBanditWizard, 1, 1)
        addLlToListIfMissing(LootWarlockSpellTomes00All15, LootForswornRandomWizard, 1, 1)
    endIf
    if (_LEARN_EnthirSells.GetValue() == 1)
        ; Re-run each alias's on init script. It will run its own checks and
        ; do what needs to be done
        enthirChestAlias.OnInit()
        ; ForceRefIfEmpty()
        tolfdirChestAlias.OnInit()
    endIf
EndFunction

function RemoveItemsFromWorld()
        ; Remove items from lists. The only clean way of doing this also removes all other
        ; script-added items from these lists. Players are asked to save and reload after disabling
        ; SpawnItems to refresh any changes to these lists from other mods. As a result, we should 
        ; ensure this function is only run when the setting is first disabled, not frequently, 
        ; as this would disrupt other mod scripts that affect these lists.
        ; Currently it is set up to ONLY run from MCMConfigQuest after the player has
        ; clicked the toggle in order to disable the setting.
        ; Why do it this way when it has problems? Well, RemoveAddedForm doesn't seem to be
        ; working and isn't documented on the wiki. An alternative to this is to set each 
        ; item's count to 0, but I have a feeling that will bork the save if players remove the
        ; mod and reload, so let's not do that.
        ;
        ; Spirit Tutor tome
        LitemSpellTomes00Conjuration.Revert()
        ; Attunement tome
        LitemSpellTomes25Alteration.Revert()
        ; Drugs, spell tomes
        LootWarlockRandom.Revert()
        LootRandomBanditWizard.Revert()
        LootForswornRandomWizard.Revert()
        ; Remove items from enthir and tolfdir's inventories
        enthirChestAlias.RemoveItems()
        tolfdirChestAlias.RemoveItems()
endFunction

function OnInit()
   
    aSchools = new String[6]
    aSchools[0] = __l("mcm_automatic", "Automatic")
    aSchools[1] = SPELL_SCHOOL_ALTERATION
    aSchools[2] = SPELL_SCHOOL_CONJURATION
    aSchools[3] = SPELL_SCHOOL_DESTRUCTION
    aSchools[4] = SPELL_SCHOOL_ILLUSION
    aSchools[5] = SPELL_SCHOOL_RESTORATION
    
    aAlterationLL = new LeveledItem[4]
    aAlterationLL[0] = LitemSpellTomes00Alteration
    aAlterationLL[1] = LitemSpellTomes25Alteration
    aAlterationLL[2] = LitemSpellTomes50Alteration
    aAlterationLL[3] = LitemSpellTomes75Alteration
    aConjurationLL = new LeveledItem[4]
    aConjurationLL[0] = LitemSpellTomes00Conjuration
    aConjurationLL[1] = LitemSpellTomes25Conjuration
    aConjurationLL[2] = LitemSpellTomes50Conjuration
    aConjurationLL[3] = LitemSpellTomes75Conjuration
    aDestructionLL = new LeveledItem[4]
    aDestructionLL[0] = LitemSpellTomes00Destruction
    aDestructionLL[1] = LitemSpellTomes25Destruction
    aDestructionLL[2] = LitemSpellTomes50Destruction
    aDestructionLL[3] = LitemSpellTomes75Destruction
    aIllusionLL = new LeveledItem[4]
    aIllusionLL[0] = LitemSpellTomes00Illusion
    aIllusionLL[1] = LitemSpellTomes25Illusion
    aIllusionLL[2] = LitemSpellTomes50Illusion
    aIllusionLL[3] = LitemSpellTomes75Illusion
    aRestorationLL = new LeveledItem[4]
    aRestorationLL[0] = LitemSpellTomes00Restoration
    aRestorationLL[1] = LitemSpellTomes25Restoration
    aRestorationLL[2] = LitemSpellTomes50Restoration
    aRestorationLL[3] = LitemSpellTomes75Restoration
    
    aInventSpellsPtr = aRestorationLL
    
    RegisterForSleep()
    UpgradeVersion()
	
endFunction

; === Chance calculations
float function scaleEffort(float effort, float minchance, float maxchance)
	float scaledEffort
	; This function optionally scales effort to be non-linear. 
	; In the original, an s-curve was used. It has been changed here slightly so that
	; at effort=0 it returns the minimum chance, and at effort=1 (max effort)
	; it returns the maximum chance. Values in between are scaled to 
	; provide a harder start (low total effort is more punished).
	; There are no diminishing returns with effort - above about 60%
	; the relationship between effort in and scaled effort is relatively linear.
    if (_LEARN_EffortScaling.GetValue() == 0) ; If preference set to scurve
		scaledEffort = (minchance + (maxchance - minchance) * (2 - 2 / (1 + (effort*effort*effort))))
	; Alternatively, you can use a square root. This provides the opposite effect.
	; Low effort values are scaled up, while higher values have diminishing returns.
    ElseIf(_LEARN_EffortScaling.GetValue() == 1) ; If preference set to square root
		scaledEffort = ((maxchance - minchance) * Math.sqrt(effort) + minchance)
	; Finally, linear 1:1 is an option. Warning that this often maxes out small discovery
	; chances, as even reaching 5% of the total amount of effort you could generate
	; (which is very easy) will result in a roll of 5%, for example.
    ElseIf(_LEARN_EffortScaling.GetValue() == 2) ; If preference set to linear
		if (effort > maxchance)
			scaledEffort = maxchance
		elseIf (effort < minchance)
			scaledEffort = minchance
		else
			scaledEffort = effort
		endIf
	Else ; This should never happen. But let's at least ensure things are happening if it does.
		return maxchance
	EndIf
    return scaledEffort 
EndFunction

float function getAverageSkill()
    float myskill = 0
    int i = 1
    ; Calculate the mean skill over all magic schools
    while (i <= 5)
        myskill += PlayerRef.GetActorValue(aSchools[i]) / 5
        i += 1
    EndWhile
    return myskill
endFunction

float function getNotesBonus(float notes, bool schoolSpecific)
    ; Amount of spell learning notes in inventory provide bonus (diminishing returns, 
	; up to max of 33% of 33% of final effort).
	; The number of notes possessed by the player is related to the value of the spells they have read.
	; So this value is normalized by comparing the value of a core spellbook 
    ; (in this case Candlelight) to accomodate some mods which alter the spell tome values. 
    ; To be honest I am really unsure if this step is necessary, because the amount of notes spawning
    ; in the player's inventory should already be adjusted in this way. But I suppose it can't hurt,
    ; and surely there is a reason it was originally added, so let's keep it.
    Book refCandleLight = Game.GetForm(0x0009E2A7) as Book
    float priceFactor = refCandleLight.GetGoldValue() / 44
    notes = notes / pricefactor
    float bnot
    ; Since these numbers are now configurable, the defaults are set in the esp.
    ; Initialize
    float maxNotesBonusRaw = 1
    float maxNotesBonusPercent = 1
    float maxNotes = 1
    ; _LEARN_maxNotesBonus is currently a percent. We want it to be on a scale from 1-300.
    ; Keeping with the 2/3 specific school and 1/3 total theme: the study power bonus for all notes
    ; is capped at a default of 50, or a defualt of 1/6 of total final effort, and is only given by the 
    ; study power when it's not used for learning/discovery.
	; Thus a school-specific note bonus will be capped at 100, or 1/3 of the total final effort.
	; Getting the default max value of 100 requires carrying a default of _LEARN_maxNotes (default 750g) worth of notes for the relevant school.
    if (schoolSpecific)
        maxNotesBonusRaw = _LEARN_maxNotesBonus.GetValue()*3
        maxNotes = _LEARN_maxNotes.GetValue()
    else
        maxNotesBonusRaw = _LEARN_maxNotesBonus.GetValue()*3/2
		maxNotes = _LEARN_maxNotes.GetValue()*5
    endIf
    maxNotesBonusPercent = maxNotesBonusRaw/100/3
    ; Used to use square root but was too punishing because reaching 100 required 100*100=10000g
    ; of school specific notes. Let's change power to require 2000g of school specific notes for max bonus of 100.
    ; Now that this amount is configurable, the proper exponent to achieve this  is automatically calculated 
    ; using logarithms based on the player's configuration.
    ; This logarithm function requires some recent version of SKSE, and it's currently undocumented on the Creation Kit wiki.
    ; I'm also not sure if it's natural or base 10 but to be honest I really don't care enough to investigate.
    ;
    ; Testing Notes
    ; After testing, diminishing returns is the only model that really makes the power worth using, so we'll go with just that.
    ; The code for the other scaling methods is below. Linear is OK but the power doesn't feel worth using until you have a lot of notes,
    ; and I haven't set up a way to configure the bonus chance scaling for notes independently from scaling of other effort components - nor am I sure I want to. This was the original
    ; design and it does seem to work fine. The problem is this number was always "double scaled", first through this diminishing returns method here
    ; and then later by the effort scaler using the s-curve (or now another method). Let's not fix what isn't broken.
    ;if (_LEARN_EffortScaling.GetValue() == 0) ; If set to punishing start, s-curve.
        ;float percentMaxNotes = 0
        ;float bnotPercent = 0
        ;percentMaxNotes = notes/maxNotes
        ;bnotPercent = scaleEffort(percentMaxNotes, 0, maxNotesBonusPercent) ; Returns a value from 0 to 1 representing the decimal percentage of the raw bonus we should get
        ;bnot = bnotPercent * maxNotesBonusRaw
    ;if (_LEARN_EffortScaling.GetValue() == 1) ; If diminishing returns scaling method, use x root method with logarithms
        float power = 1
        power = 1/(Math.log(maxNotes)/Math.log(maxNotesBonusRaw))
        bnot = Math.pow(notes, power)
    ;if(_LEARN_EffortScaling.GetValue() == 2 || _LEARN_EffortScaling.GetValue() == 0) ; Linear scaling for tough start or linear
    ;    bnot = (notes/maxNotes)*maxNotesBonusRaw
    ;endIf
    ; Cap at max value
    if (bnot > maxNotesBonusRaw)
        bnot = maxNotesBonusRaw
    endIf
    return bnot
endFunction

float function calcEffort(float skill, float casts, float notes)
    float effort
	; result is on a scale of 0-1ish.
	; with enough bonus it can go above 1.
	; it's made of three things:
	; myskill (considering magic skill levels)
	; mycasts (spell casts of same school)
	; mybonus (other roleplaying bonus)

	; calculate myskill
    float myskill = 0 ; out of 100
    myskill = getAverageSkill()
    ; That will count for 1/3rd
    myskill /= 3
    ; specific magic school skill (passed in) will count for 2/3rds
    myskill += skill * 2 / 3

	; cap the passed mycasts at 100 casts.
    float mycasts = casts ; maximum 100
    if (mycasts > 100)
        mycasts = 100
    endif
 
    ; calculate mybonus
    float mybonus = 0 ; no cap. enough bonus can make up for lacking in other two.
	; the CountBonus variable is accessed by other scripts to add more to the bonus.
	; For example, the removed dialogue option used this variable.
	; The random "dream" bonus/penalty, the Daedric Tutor, and the study power bonus use this value.
    mybonus += _LEARN_CountBonus.GetValue()
    mybonus += getNotesBonus(notes, true)
    ; Check for drug bonus
    if (PlayerRef.HasMagicEffect(AlchDreadmilkEffect)) ; dreadmilk
        mybonus += 300 ; Dreadmilk gives automatic max total effort, and therefore automatic max roll.
    elseif (PlayerRef.HasMagicEffect(AlchShadowmilkEffect)) ; shadowmilk
        mybonus += 60 ; Shadowmilk provides 20% of total effort all by itself. This can help bypass the "tough start" hump.
    endif
    ; Check for good location
    Location currentLocation = PlayerRef.GetCurrentLocation()
    if (currentLocation)
        if (currentLocation.HasKeyword(LocTypeTemple) || currentLocation.HasKeyword(LocTypePlayerHouse) || currentLocation.isSameLocation(customLocation))
            mybonus += 22
        elseIf (currentLocation.isSameLocation(WinterholdCollegeLocation) || WinterholdCollegeLocation.isChild(currentLocation))
            mybonus += 33
		elseIf (currentLocation.HasKeyword(LocTypeInn))
			mybonus += 11
        endif
    endIf
    ; Failing to learn also counts as progress for rng roll, 
    ; but only if some role playing is already happening
    if (mybonus >= 33)
        mybonus += iFailuresToLearn * 11
    endif
	; scale mybonus using the configurable BonusScale parameter (default 1, max 3)
    mybonus = mybonus * _LEARN_BonusScale.GetValue()
	
    effort = ((myskill + mycasts + mybonus) / 3 / 100)
	; cap effort at 1
	; this ensures the bonus value can only make up for lost effort from myskill and mycast.
	; gives cleaner math for scaling, as effort scales exactly from 0 to 1.
    if (effort < 0)
        effort = 0
	ElseIf (effort > 1)
		effort = 1
    EndIf
    return effort
EndFunction

float function calcCDReffort()
	float mycasts = getTotalCasts()
	; mycasts max of 500 - 100 of each school counted.
	; we will cap it at 100 because 500 spell casts per rest is not realistic?
	if (mycasts > 100)
		mycasts = 100
	endIf
	; weighting is here and not configurable atm.
	return ((mycasts)/100) 
endFunction

float function getSkillDiffFactor(String magicSchool, MagicEffect eff)
        float fskill
        fskill = PlayerRef.GetActorValue(magicSchool)
        ; Get player skill of specific school
        float sskill = 0
        sskill = PlayerRef.GetActorValue(magicSchool)
        ; Get average magical skill
        float tskill = 0
        tskill = getAverageSkill()
        ; Using same 1/3 and 2/3 proportions as for learning, make the value used to represent 
        ; the player's overall skill for this calculation
        fskill = (0.66*sskill) + (0.33*tskill)
        ; Get level of spell effect being learned
        float magicLevel = 0
        magicLevel = eff.GetSkillLevel()
        ; If it's a novice spell, set it to 12.5 so we don't divide by zero later.
        ; Setting it to 1 seems to make sense until you realize we are later
        ; multiplying chance by the player's skill level if we do that. So we'll go 
        ; for halfway to apprentice, so learning apprentice spells is still twice
        ; as hard with adjustment.
        if (magicLevel == 0)
            magicLevel = 12.5
        endIf
        ; Calculate proportion of player skill to spell difficulty
        float skillDiff = 0
        ; it's impossible for fskill to be 0 so we won't worry about that
        skillDiff = magicLevel/fskill
        return skillDiff
endFunction

float function baseChanceBySchool(string magicSchool, float minchance, float maxchance, MagicEffect eff, bool discovering)
    float fskill
    fskill = PlayerRef.GetActorValue(magicSchool)
    float fcasts
    float fnotes
    float fChance
    if magicSchool == SPELL_SCHOOL_ALTERATION
        fcasts = _LEARN_CountAlteration.GetValue()
        fnotes = PlayerRef.GetItemCount(_LEARN_SpellNotesAlteration)
    elseIf magicSchool == SPELL_SCHOOL_CONJURATION
        fcasts = _LEARN_CountConjuration.GetValue()
        fnotes = PlayerRef.GetItemCount(_LEARN_SpellNotesConjuration)
    elseIf magicSchool == SPELL_SCHOOL_DESTRUCTION
        fcasts = _LEARN_CountDestruction.GetValue()
        fnotes = PlayerRef.GetItemCount(_LEARN_SpellNotesDestruction)
    elseIf magicSchool == SPELL_SCHOOL_ILLUSION
        fcasts = _LEARN_CountIllusion.GetValue()
        fnotes = PlayerRef.GetItemCount(_LEARN_SpellNotesIllusion)
    elseIf magicSchool == SPELL_SCHOOL_RESTORATION
        fcasts = _LEARN_CountRestoration.GetValue()
        fnotes = PlayerRef.GetItemCount(_LEARN_SpellNotesRestoration)
    endIf    
    ; Get the chance from effort calculations, scaling as configured.
    fChance = scaleEffort(calcEffort(fskill, fcasts, fnotes), minchance / 100, maxchance / 100)
	; Check to see if dynamic difficulty is enabled.
    ; If it is, then adjust the returned chance accordingly to make it more/less likely to learn the spell.
    ; This only applies to spell learning, not discovery, so a passed bool lets us disable it.
	if (_LEARN_DynamicDifficulty.GetValue() == 1 && !discovering)
        ; Use skilldiff to change returned chance to learn.
        ; when your skill is lower than spell level, skillDiff is >1
        ; when your skill is higher, skillDiff is <1
        ; fChance is used as the upper bound in rollToLearn()
        ; so making it bigger makes learning more likely.
        float skillDiff = 1
        skillDiff = getSkillDiffFactor(magicSchool, eff)
        fChance = fChance/skillDiff
        ; Make sure we don't go over or below max/min chance
        if (fChance < minchance/100)
            fChance = minchance/100
        elseIf (fChance > maxchance/100)
            fChance = maxchance/100
        endIf
    endIf
    return fChance
EndFunction

float Function baseChanceToStudy(string magicSchool = "")
    Magiceffect me
	if (magicSchool == "")
        if iCount == 0
            return 0
        endif
        Spell sp = spell_fifo_peek()
        if (sp == None)
            return 1
        endif
        me = sp.GetNthEffectMagicEffect(0)
        if (me == None)
            return 1
        endif
        magicSchool = me.GetAssociatedSkill()
        if (magicSchool == "")
            return 1
        endif
    endif
    return baseChanceBySchool(magicSchool, _LEARN_MinChanceStudy.GetValue(), _LEARN_MaxChanceStudy.GetValue(), me, false) 
EndFunction

float Function baseChanceToDiscover(string magicSchool = "")
	if (magicSchool == "")
        magicSchool = topSchoolToday()
    EndIf
	; Pass an arbitrary magiceffect. It won't be used thanks to the boolean.
    return baseChanceBySchool(magicSchool, _LEARN_MinChanceDiscover.GetValue(), _LEARN_MaxChanceDiscover.GetValue(), _LEARN_PracticeEffect, true) 
EndFunction

float function getTotalCasts()
	return (_LEARN_CountAlteration.GetValue() + _LEARN_CountDestruction.GetValue() + _LEARN_CountConjuration.GetValue() + _LEARN_CountRestoration.GetValue() + _LEARN_CountIllusion.GetValue())
endFunction

float function getTotalNotes()
	return (PlayerRef.GetItemCount(_LEARN_SpellNotesAlteration) + PlayerRef.GetItemCount(_LEARN_SpellNotesConjuration) + PlayerRef.GetItemCount(_LEARN_SpellNotesDestruction) + PlayerRef.GetItemCount(_LEARN_SpellNotesIllusion) + PlayerRef.GetItemCount(_LEARN_SpellNotesRestoration))
endFunction

; === Time management
float Function hours_before_next_ok_to_learn()
    float now = GameDaysPassed.GetValue()
	float nextOK = LastLearnTime + 1
	; If cooldown reduction is enabled, then reduce the required wait time accordingly.
	if (_LEARN_IntervalCDREnabled.GetValue() == 1)
		float actualCDR = 0
		actualCDR = scaleEffort(calcCDReffort(), 0, (_LEARN_IntervalCDR.GetValue() / 100))
		nextOK = LastLearnTime + _LEARN_StudyInterval.GetValue()*(1-actualCDR)
	Else
		nextOK = LastLearnTime + _LEARN_StudyInterval.GetValue() ; default is 0.65
	EndIf

    if now >= nextOK
        return 0
    Else
        return ((nextOK - now) * 24)
    endif
EndFunction

float Function hours_before_next_ok_to_discover()
    float now = GameDaysPassed.GetValue()
	float nextOK = LastDiscoverTime + 1
	; If cooldown reduction is enabled, then reduce the required wait time accordingly.
	if (_LEARN_IntervalCDREnabled.GetValue() == 1)
		float actualCDR = 0
		actualCDR = scaleEffort(calcCDReffort(), 0, (_LEARN_IntervalCDR.GetValue() / 100))
		nextOK = LastDiscoverTime + _LEARN_StudyInterval.GetValue()*(1-actualCDR)
	Else
		nextOK = LastDiscoverTime + _LEARN_StudyInterval.GetValue() ; default is 0.65
	EndIf

    if now >= nextOK
        return 0
    Else
        return ((nextOK - now) * 24)
    endif
EndFunction

float function hours_before_next_ok_to_sleep()
    float now = GameDaysPassed.GetValue()
    float nextOK = LastSleepTime + 1
    nextOK = LastSleepTime + _LEARN_StudyInterval.GetValue()
    if now >= nextOK
        return 0
    Else
        return ((nextOK - now) * 24)
    endif
endFunction

; === Learning and discovery helper functions
function tryLearnSpell(Spell sp, int fifoIndex, bool forceSuccess)
    ; Initialize variables
	float fChance
	MagicEffect eff
	String magicSchool = SPELL_SCHOOL_DESTRUCTION
	; debug check to ensure everything still exists
	if (!debugCheck(sp, fifoindex))
		return ; break if debug check fails
	else
		eff = sp.GetNthEffectMagicEffect(0)
		magicSchool = eff.GetAssociatedSkill()
	endif

	; if passed bool forceSuccess is true, just succeed
	if (forceSuccess)
		notify(formatString1(__l("notification_effortless_learn", "{0} came effortlessly to you."), sp.GetName()), NOTIFICATION_LEARN_SPELL)
		forceLearnSpellAt(fifoindex, (VisibleNotifications[NOTIFICATION_VANILLA_ADD_SPELL]))
		iFailuresToLearn = 0
		return
	EndIf
	
	; Otherwise, roll to learn the spell
	if ((rollToLearn(baseChanceToStudy(magicSchool),sp) || PlayerRef.HasSpell(sp))) 
		notify(formatString1(__l("notification_learn_spell", "It all makes sense now! Learned {0}."), sp.GetName()), NOTIFICATION_LEARN_SPELL)
		forceLearnSpellAt(fifoindex, (VisibleNotifications[NOTIFICATION_VANILLA_ADD_SPELL]))
		iFailuresToLearn = 0 
	Else 
		iFailuresToLearn = iFailuresToLearn + 1
        notify(formatString1(__l("notification_fail_spell", "{0} still makes no sense..."), sp.GetName()), NOTIFICATION_LEARN_FAIL)
	EndIf
EndFunction

String function topSchoolToday()
    string magicSchool
    if (_LEARN_ForceDiscoverSchool.GetValue() != 0)
        magicSchool = aSchools[_LEARN_ForceDiscoverSchool.GetValueInt()]
    else
        ; Determine the school PC most used today
        magicSchool = SPELL_SCHOOL_RESTORATION ; default to Restoration just because.
        float fTopCount = _LEARN_CountRestoration.getvalue()
        aInventSpellsPtr = aRestorationLL
        if (_LEARN_CountDestruction.GetValue() > fTopCount)
            magicSchool = SPELL_SCHOOL_DESTRUCTION
        EndIf
        if (_LEARN_CountConjuration.GetValue() > fTopCount)
            magicSchool = SPELL_SCHOOL_CONJURATION
        EndIf
        if (_LEARN_CountAlteration.GetValue() > fTopCount)
            magicSchool = SPELL_SCHOOL_ALTERATION
        EndIf
        if (_LEARN_CountIllusion.GetValue() > fTopCount)
            magicSchool = SPELL_SCHOOL_ILLUSION
        EndIf
    endif

    if magicSchool == SPELL_SCHOOL_ALTERATION
        aInventSpellsPtr = aAlterationLL
    elseIf magicSchool == SPELL_SCHOOL_CONJURATION
        aInventSpellsPtr = aConjurationLL
    elseIf magicSchool == SPELL_SCHOOL_DESTRUCTION
        aInventSpellsPtr = aDestructionLL
    elseIf magicSchool == SPELL_SCHOOL_ILLUSION
        aInventSpellsPtr = aIllusionLL
    elseIf magicSchool == SPELL_SCHOOL_RESTORATION 
        aInventSpellsPtr = aRestorationLL
    endIf
    
    return magicSchool
EndFunction

bool function rollToLearn(float fChance, Spell sp)
	Float fRand
	; ...check to see if HarderParallel is enabled. If it is, divide chance by number of spells being learned.
	if (_LEARN_HarderParallel.GetValue() != 0) 
		fRand = Utility.RandomFloat(0.0, 1.0)
		fRand = fRand * _LEARN_ParallelLearning.GetValue()
	Else ; Otherwise, roll as normal.
		fRand = Utility.RandomFloat(0.0, 1.0)
	EndIf
	
	; Once you have the roll, compare it to the chance. If it passes, return a True boolean.
	if (fRand < fChance)
		return True
	Else
		return False
	EndIf
EndFunction

bool function debugCheck(Spell sp, int fifoindex)
	MagicEffect eff
	; Debug checks - make sure spell and spell effect exists, get spell school
	if (! sp)
		notify(__l("message_spell_learning_bad_reference", "[Spell Learning] Error learning spell, removing entry from list."), NOTIFICATION_ERROR)
		spell_list_removeAt(fifoindex) ; TODO something better to handle spell mod disappearance ?
		return false
	endif
	eff = sp.GetNthEffectMagicEffect(0)
	if (!eff)
		notify(__l("notification_unknown_spell", "[Spell Learning] Unknown spell in learning list - other spell mod removed?"), NOTIFICATION_ERROR)
		return false
	else
		return true
	endIf
endFunction

bool function canAutoLearn(Spell sp, int fifoindex)
    ; Initialize variables
	MagicEffect eff
	String magicSchool = SPELL_SCHOOL_DESTRUCTION
	int magicLevel = 100
	float fskill = 0
	float pskill = 0
	; debug check to ensure everything still exists
	if (!debugCheck(sp, fifoindex))
		return False
	endif
	; If debug checks are passed, compare spell's level to player's skill and auto learn if eligible.
	; initialize more variables now that we know they really exist
	eff = sp.GetNthEffectMagicEffect(0)
	magicSchool = eff.GetAssociatedSkill()
	magicLevel = eff.GetSkillLevel()
	fskill = PlayerRef.GetActorValue(magicSchool)
	if ((pskill - _LEARN_AutoNoviceLearning.GetValue()) >= magicLevel)
		return True
	Else
		return False
	EndIf
EndFunction

bool function cannotLearn(Spell sp, int fifoindex)
	; First things first: if configured to allow dreadmilk to bypass autofail,
	; and under the effects of dreadmilk, then just return False.
	if ((PlayerRef.HasMagicEffect(AlchDreadmilkEffect)) && _LEARN_PotionBypass.GetValue() == 1)
		return False
	EndIf
    ; Initialize variables
	MagicEffect eff
	String magicSchool = SPELL_SCHOOL_DESTRUCTION
	int magicLevel = 100
	float fskill = 0
	float pskill = 0
	; debug check to ensure everything still exists
	if (!debugCheck(sp, fifoindex))
		return True
	endif
	; If debug checks are passed, compare spell's level to player's skill and auto learn if eligible.
	; initialize more variables now that we know they really exist
	eff = sp.GetNthEffectMagicEffect(0)
	magicSchool = eff.GetAssociatedSkill()
	magicLevel = (eff.GetSkillLevel())
	fskill = PlayerRef.GetActorValue(magicSchool)
	if (pskill > (_LEARN_TooDifficultDelta.GetValue() - magicLevel))
		return True
	Else
		return False
	EndIf
EndFunction

function doLearning()
    Spell sp
    bool emergencyBreaks = false
	int alreadyLearnedSpells = 0
    ; The main "spell learning" function. Goes through the list according to the player's settings
    ; and attempts to learn new spells.

    ; First things first: If auto-successes bypass the daily limit, then process them all first.
	if (_LEARN_AutoNoviceLearningEnabled.GetValue() == 1 && _LEARN_AutoSuccessBypassesLimit.GetValue() == 1)
		int currentSpell = 0
		while (currentSpell < spell_fifo_get_count())
			sp = spell_fifo_peek(currentSpell)
			if(canAutoLearn(sp, currentSpell))
				tryLearnSpell(sp, currentSpell, true)
			endIf
			currentSpell = currentSpell + 1
		endWhile
    endIf
    
    	; Before the main spell learning cycle, if we've reached the max amount of failures, we'll handle that here first.
	; As long as the setting is enabled, obviously.
	if (iFailuresToLearn >= _LEARN_MaxFailsBeforeCycle.GetValue() && _LEARN_MaxFailsBeforeCycle.GetValue() != 0)
		sp = spell_fifo_peek()
		if (_LEARN_MaxFailsAutoSucceeds.GetValue() == 1 && (_LEARN_TooDifficultEnabled.GetValue() == 0 || !cannotLearn(sp, 0))) 
		; If reaching the max amount of fails is supposed to make you auto succeed and it's not an automatic failure for some other reason...
            ; ...then automatically learn the spell.
            notify(formatString1(__l("notification_fail_upwards", "It's finally coming together! Learned {0}."), sp.GetName()), NOTIFICATION_LEARN_SPELL)
			forceLearnSpellAt(0, (VisibleNotifications[NOTIFICATION_VANILLA_ADD_SPELL]))
			iFailuresToLearn = 0
			alreadyLearnedSpells = alreadyLearnedSpells + 1
		else ; Otherwise it's supposed to just move the spell to the bottom of the list.
			MoveSpellToBottom(0)
			iFailuresToLearn = 0
            notify(formatString1(__l("notification_moving_on", "Not making any progress on {0}... trying other spells."), sp.GetName()), NOTIFICATION_MOVING_ON)
		endIf
	endIf
	
	; main spell learning loop
	if (true)
		; initialize variables only used in this loop
		int currentSpell = 0
		float spellLimit = 1
		; set the spell limit
		if (_LEARN_AutoSuccessBypassesLimit.GetValue() == 1 && _LEARN_MaxFailsAutoSucceeds.GetValue() == 0)
			; if all the ways spells could be learned before are off or are set
			; to not count towards the limit, then the limit is just the amount of spells per
			; day to learn
			spellLimit = _LEARN_ParallelLearning.GetValue()
		else
			; otherwise, subtract the already learned spells counter from the amount of available spells to learn
			spellLimit = _LEARN_ParallelLearning.GetValue()-alreadyLearnedSpells
		endIf
		; while below max daily limit AND not yet at end of list, iterate through and try to learn
		while (currentSpell < spellLimit && currentSpell < spell_fifo_get_count() && !emergencyBreaks) 
			; get the current spell
			sp = spell_fifo_peek(currentSpell)
			; initialize some variables here.
			; they are only used in the loop below.
			; if we initialize them in that loop they'll reset,
			; so we do it here.
			bool unbroken = true
			int insideCount = 0
			; Loop to repeatedly check to see if top spell is unlearnable.
			; If it is, move it to the bottom of the list and keep checking
			; until it is learnable or we have exhausted the list.
			While (unbroken)
				bool foundLearnableSpell = false
				sp = spell_fifo_peek(currentSpell)
				if(cannotLearn(sp, currentSpell) && _LEARN_TooDifficultEnabled.GetValue() == 1)
					MoveSpellToBottom(currentSpell)
					notify(formatString1(__l("notification_impossible_spell", "{0} is too difficult. Trying other spells first."), sp.GetName()), NOTIFICATION_MOVING_ON)
					insideCount = insideCount + 1
					; test to see if we've iterated through the whole list, meaning all spells are too hard.
					if ((currentSpell+insideCount) >= spell_fifo_get_count())
						; if we have, then break the loop to prevent an endless loop.
						unbroken = false
					endIf
				else
					; If we find one that is learnable, learn it and break the loop.
					unbroken = false
					foundLearnableSpell = true
				endIf
				if (!foundLearnableSpell && ((currentSpell+insideCount) >= spell_fifo_get_count()))
					; if we didn't find a learnable spell in the entire list,
					; put on the emergency breaks to prevent outer loop from going again
					; which would spam failure messages exponentially
					emergencyBreaks = true
				elseIf(foundLearnableSpell)
					tryLearnSpell(sp, currentSpell, false)
				endIf
			endWhile
			currentSpell = currentSpell + 1
		endWhile
    endIf

    ; Reset learning timer
    LastLearnTime = GameDaysPassed.GetValue()

endFunction

Spell function doDiscovery()
    ; The main "Spell Discovery" function.
    String sSchool = topSchoolToday()
    float fSkill = PlayerRef.GetActorValue(sSchool)
    float baseChance = baseChanceToDiscover(sSchool)
    
    float fRand = Utility.RandomFloat(0.0, 1.0) 
    if (fRand > baseChance) 
        ; Reset discovery timer
        LastDiscoverTime = GameDaysPassed.GetValue()
        ; Spell discovery failure ! 
        Return None
    EndIf
    
    int llidx
    if (fskill < 25)
        llidx = 0
    elseif (fskill < 50)
        llidx = 1
    elseif (fskill < 75)
        llidx = 2
    Else
        llidx = 3
    EndIf
    LeveledItem ll = aInventSpellsPtr[llidx]
    int llcount = ll.GetNumForms()
    int limit = 10
    int spidx = Utility.RandomInt(0, llcount - 1)

    Book inventedbook = ll.GetNthForm(spidx) as Book
    Spell inventedsp = inventedbook.getspell()
    
    if inventedsp == None
        notify(__l("notification_spell_invention_bug", "[Spell Learning] Error: A spell tome in your game has no linked spell."), NOTIFICATION_ERROR)
        ; Reset discovery timer
        ;LastDiscoverTime = GameDaysPassed.GetValue()
        return None
    endif
    
    while (inventedsp && (PlayerRef.HasSpell(inventedsp) || spell_fifo_has_ref(inventedsp)) && limit > 0)
        spidx = (spidx + 1) % llcount
        inventedbook = ll.GetNthForm(spidx) as Book
        inventedsp = inventedbook.getspell()
        limit -=1
    EndWhile
    
    if (inventedsp && (! (PlayerRef.HasSpell(inventedsp) || spell_fifo_has_ref(inventedsp))))
        notify(formatString1(__l("notification_new_spell_idea", "An idea for a new spell came to you: {0}!"), inventedsp.GetName()), NOTIFICATION_DISCOVERY)
        spell_fifo_push(inventedsp)
        updateSpellLearningEffect()
        Bookextension.setreadWFB(inventedbook, true)
    EndIf
    
    ; Reset discovery timer
    LastDiscoverTime = GameDaysPassed.GetValue()

EndFunction

function doDream()
    float fRand = 1
    fRand = Utility.RandomFloat(0.0, 1.0)
    if (fRand < 0.01)
        notify(__l("notification_dreamt_Julianos", "You dreamt that Julianos was watching over you."), NOTIFICATION_DREAM)
        _LEARN_CountBonus.SetValue(100)
    ElseIf (fRand < 0.02)
        notify(__l("notification_dreamt_flying", "You dreamt that you were flying over Solstheim."), NOTIFICATION_DREAM)
        _LEARN_CountBonus.SetValue(30)
    ElseIf (fRand < 0.03)
        notify(__l("notification_dreamt_exam", "You had a nightmare about being lost forever in a plane of Oblivion."), NOTIFICATION_DREAM)
        _LEARN_CountBonus.SetValue(-40)
    endif
endFunction

function doReset()
    ; reset counters and limits for the cycle
    ; These are bonuses only that get reset here. 
    ; Any negative effects that tick down are tied to the sleep cooldown.
    _LEARN_CountAlteration.SetValue(0.0)
    _LEARN_CountConjuration.SetValue(0.0)
    _LEARN_CountDestruction.SetValue(0.0)
    _LEARN_CountIllusion.SetValue(0.0)
    _LEARN_CountRestoration.SetValue(0.0)
    _LEARN_CountBonus.SetValue(0.0)
    _LEARN_AlreadyUsedTutor.SetValue(0)
    _LEARN_LastDayStudied.SetValue(0)
    ; this function checks to see if the proper config setting is enabled so we don't need to here
    ; the purpose of having this here is if a player turns on the setting mid-play,
    ; otherwise it wouldn't be refreshed until the next load game.
    ; checks in the function ensure everything is only added once, so it does no harm.
    SpawnItemsInWorld() 
endFunction

function updateSpellLearningEffect()
    if ((iCount <= 0) && (PlayerRef.hasSpell(_LEARN_SpellsToLearn)))
        ; If there are no more spells to learn and the player has the effect, remove it.
        PlayerRef.removeSpell(_LEARN_SpellsToLearn)
    elseIf ((iCount > 0) && !(PlayerRef.hasSpell(_LEARN_SpellsToLearn)))
        ; If there are spells to learn and the player doesn't have the effect, add it silently.
        PlayerRef.addSpell(_LEARN_SpellsToLearn, false)
    endIf
endFunction

; === Tracked player events
Event OnSleepStop(Bool abInterrupted)
	
	; Test conditions for doing absolutely nothing
    if (abInterrupted)
        ; If sleep was interrupted. 
        notify(__l("notification_sleep_interrupted", "Your sleep was interrupted."), NOTIFICATION_FORCE_DISPLAY)
        return
    endIf

    ; If we pass the checks and they are enabled and off cooldown, then do the things.
    ; In the case that anything fails, check to see if we've already sent a notification, and if we have, don't send another.
    if (_LEARN_LearnOnSleep.GetValue() == 1 && hours_before_next_ok_to_learn() <= 0 && spell_fifo_get_count() != 0)
        ; This only runs and resets the learning cooldown if there's actually something to learn.
        doLearning()
    elseIf (_LEARN_LearnOnSleep.GetValue() == 1 && hours_before_next_ok_to_learn() > 0)
        ; This is really the only mandatory "nothing happened" style notification so most other things have been removed
        notify(__l("notification_slept_too_soon", "Your mind isn't settled enough yet to learn any spells..."), NOTIFICATION_TOO_SOON)
    endIf
    if (_LEARN_DiscoverOnSleep.GetValue() == 1 && hours_before_next_ok_to_discover() <= 0)
        doDiscovery()
    endIf

    ; All the functionality tied to a sleep-specific cooldown
    if (hours_before_next_ok_to_sleep() <= 0)
        ; Chance to heal Dreadstare disease (this is only on rest, not on study so 
        ; it's not broken out into the "reset" function)
        if (PlayerRef.HasSpell(_LEARN_DiseaseDreadmilk))
            float fRand = 0
            fRand = Utility.RandomFloat(0.0, 1.0)
            if (fRand > (0.2 - 0.1*_LEARN_consecutiveDreadmilk.GetValue()))
                notify(__l("notification_no_more_dreadmilk_addiction", "You're finally starting to feel your dreadmilk craving wane."), NOTIFICATION_DREADMILK)
                PlayerRef.RemoveSpell(_LEARN_DiseaseDreadmilk)
            endif
        endif
        
        ; Reduce blood toxicity
        if (_LEARN_consecutiveDreadmilk.GetValue() > 0)
            _LEARN_consecutiveDreadmilk.Mod(-1)
            if (_LEARN_consecutiveDreadmilk.GetValue() <= 0 && !PlayerRef.HasMagicEffect(AlchDreadmilkEffect))
                _LEARN_consecutiveDreadmilk.SetValue(0)
                notify(__l("notification_dreadmilk_out_of_system", "All the Dreadmilk is finally out of your system..."), NOTIFICATION_DREADMILK)
                if (PlayerRef.HasSpell(_LEARN_DiseaseDreadmilk))
                    PlayerRef.RemoveSpell(_LEARN_DiseaseDreadmilk)
                endIf
            endIf
        endIf

        ; Reset sleep cooldown and once-per-cycle bonuses
        LastSleepTime = GameDaysPassed.GetValue()
        doReset()

        ; Dreams after we reset the bonus
        doDream()
    endIf

EndEvent




